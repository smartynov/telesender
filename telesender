#!/usr/bin/env python3

import sys
import argparse
import asyncio
from telethon import TelegramClient, errors

async def list_chats(client):
    async for dialog in client.iter_dialogs():
        try:
            print(f"{dialog.id}: {dialog.name}")
        except AttributeError:
            pass  # Skip if chat has no name

async def send_messages(client, args):
    try:
        if args.chat_id:
            entity = await client.get_entity(int(args.chat_id))
        else:
            print("Error: --chat-id is required unless using --list-chats.", file=sys.stderr)
            sys.exit(1)
    except ValueError:
        print("Invalid chat ID. Please provide a valid integer.", file=sys.stderr)
        sys.exit(1)
    except errors.RPCError as e:
        print(f"Error fetching chat entity: {e}", file=sys.stderr)
        sys.exit(1)

    def message_generator():
        buffer = ''
        in_multiline = False
        for line in sys.stdin:
            line = line.rstrip('\n')
            if in_multiline:
                buffer += '\n' + line
                if line.endswith('"') and not line.endswith('\\"'):
                    in_multiline = False
                    yield buffer
                    buffer = ''
            else:
                if line.strip() == '':
                    continue  # Skip empty lines
                if ':' in line:
                    # Check if content starts with a quote
                    colon_index = line.find(':')
                    remainder = line[colon_index+1:].strip()
                    if remainder.startswith('"'):
                        buffer = line
                        if remainder.endswith('"') and not remainder.endswith('\\"'):
                            yield buffer
                            buffer = ''
                        else:
                            in_multiline = True
                    else:
                        yield line
                elif line.startswith('"'):
                    buffer = line
                    if line.endswith('"') and not line.endswith('\\"'):
                        yield buffer
                        buffer = ''
                    else:
                        in_multiline = True
                else:
                    yield line

    async for message in async_message_processor(message_generator()):
        try:
            await send_message(client, entity, message)
        except Exception as e:
            print(f"Failed to send message: {e}", file=sys.stderr)

async def async_message_processor(generator):
    for message in generator:
        yield message

async def send_message(client, entity, message_line):
    message_line = message_line.strip()
    if not message_line:
        return  # Skip empty messages

    msg_type = 'text'
    content = ''
    file_path = None

    # Check for message type and parameters
    if ':' in message_line:
        parts = message_line.split(':', 2)
        if len(parts) == 2:
            msg_type, remaining = parts
            msg_type = msg_type.strip().lower()
            remaining = remaining.strip()
            if msg_type in ['photo', 'video', 'file']:
                file_path = remaining
            else:
                content = remaining
        elif len(parts) == 3:
            msg_type, file_path, remaining = parts
            msg_type = msg_type.strip().lower()
            file_path = file_path.strip()
            content = remaining.strip()
        else:
            content = message_line
    else:
        content = message_line

    # Handle multiline content enclosed in double quotes
    if content.startswith('"') and content.endswith('"') and len(content) >= 2:
        content = content[1:-1]  # Remove the surrounding quotes
    elif content.startswith('"'):
        content = content[1:]  # Remove the opening quote
    elif content.endswith('"'):
        content = content[:-1]  # Remove the closing quote

    # Unescape any escaped quotes
    content = content.replace('\\"', '"')

    # Process the message
    if msg_type == 'text':
        await client.send_message(entity, content, parse_mode=None)
    elif msg_type == 'markdown':
        await client.send_message(entity, content, parse_mode='markdown')
    elif msg_type == 'photo':
        caption = content if content else None
        await client.send_file(entity, file_path, caption=caption)
    elif msg_type == 'video':
        caption = content if content else None
        await client.send_file(entity, file_path, caption=caption, supports_streaming=True)
    elif msg_type == 'file':
        caption = content if content else None
        await client.send_file(entity, file_path, caption=caption)
    else:
        print(f"Unknown message type: {msg_type}", file=sys.stderr)

def main():
    parser = argparse.ArgumentParser(description='Send messages to Telegram chats.')
    parser.add_argument('--api-id', required=True, help='Telegram API ID')
    parser.add_argument('--api-hash', required=True, help='Telegram API Hash')
    parser.add_argument('--chat-id', help='Target chat ID')
    parser.add_argument('--list-chats', action='store_true', help='List recent chats')
    args = parser.parse_args()

    async def run():
        # Use the client as an asynchronous context manager
        async with TelegramClient('telesender', int(args.api_id), args.api_hash) as client:
            if args.list_chats:
                await list_chats(client)
            else:
                await send_messages(client, args)

    try:
        asyncio.run(run())
    except KeyboardInterrupt:
        print("Interrupted by user.", file=sys.stderr)
        sys.exit(1)
    except errors.RPCError as e:
        print(f"Telegram API error: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()

